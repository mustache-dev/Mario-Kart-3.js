/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 --transform --types witch-test.glb 
Files: witch-test.glb [12.1MB] > C:\Users\mouli\mk3\public\models\witch-test-transformed.glb [2.51MB] (79%)
*/

import * as THREE from 'three'
import React, { useEffect, useRef, MutableRefObject } from 'react'
import { useFrame, useGraph } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF, SkeletonUtils } from 'three-stdlib'
import { LoopOnce, LoopRepeat } from 'three'
import { Wheels } from './Wheels'
import { damp } from 'three/src/math/MathUtils.js'
import { VFXEmitter } from 'wawa-vfx'
import { useGameStore } from '../store.js'
import Flames from '../particles/drift/flames/Flames.jsx'
import { SMOKE_VFX_SETTINGS } from '../constants.js'

type ActionName = 'metarig' | 'drift-intense-left' | 'drift-intense-right' | 'drift-low-left' | 'drift-low-right' | 'drift-neutral-left' | 'drift-neutral-right' | 'IDLE' | 'IDLE-KART' | 'reverse' | 'reverse-left' | 'reverse-right-baked' | 'TURN-LEFT' | 'TURN-RIGHT' | 'wind'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Circle: THREE.Mesh
    Cube: THREE.Mesh
    Cube001_1: THREE.Mesh
    Cube003: THREE.Mesh
    Circle001: THREE.SkinnedMesh
    body: THREE.Mesh
    wheel_0: THREE.Mesh
    Cube004: THREE.SkinnedMesh
    Cube005: THREE.SkinnedMesh
    Cube006: THREE.SkinnedMesh
    Cylinder: THREE.SkinnedMesh
    root: THREE.Bone
    ['MCH-torsoparent']: THREE.Bone
    Bone: THREE.Bone
    neutral_bone: THREE.Bone
    ['MCH-hand_ikparentL']: THREE.Bone
    ['MCH-upper_arm_ik_targetparentL']: THREE.Bone
    ['MCH-hand_ikparentR']: THREE.Bone
    ['MCH-upper_arm_ik_targetparentR']: THREE.Bone
    ['MCH-foot_ikparentL']: THREE.Bone
    ['MCH-thigh_ik_targetparentL']: THREE.Bone
    ['MCH-foot_ikparentR']: THREE.Bone
    ['MCH-thigh_ik_targetparentR']: THREE.Bone
  }
  materials: {
    ['Material.004']: THREE.MeshStandardMaterial
    ['Material.005']: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.006']: THREE.MeshStandardMaterial
    ['Material.007']: THREE.MeshStandardMaterial
    m_Body: THREE.MeshStandardMaterial
    m_Tire: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.003']: THREE.MeshStandardMaterial
    Material: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

interface Witch2Props {
  speed: MutableRefObject<number>
  inputTurn: MutableRefObject<number>
  driftDirection: MutableRefObject<number>
  driftPower: MutableRefObject<number>
  backWheelOffset: MutableRefObject<{ left: number; right: number }>
  jumpOffset: MutableRefObject<number>
}

export function Witch2({ speed, inputTurn, driftDirection, driftPower, backWheelOffset, jumpOffset }: Witch2Props) {
  const group = useRef<THREE.Group>(null)
  const { scene, animations } = useGLTF('./models/witch-test-transformed.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult
  const { actions } = useAnimations(animations, group)

  const windActionRef = useRef<THREE.AnimationAction | null>(null)
  const wheelsRef = useRef<THREE.Group>(null)
  const currentAction = useRef<THREE.AnimationAction | null>(null)
  const sceneRef = useRef<THREE.Group>(null)
  const wheelPRY = useRef<[number, number, number] | null>(null)

  const kartBodyRef = useRef<THREE.Mesh>(null)

  const smoke1Ref = useRef<any>(null)
  const smoke2Ref = useRef<any>(null)
  const flamePositionLeftRef = useRef<THREE.Group>(null)
  const flamePositionRightRef = useRef<THREE.Group>(null)

  // Track if we've already transitioned into poses
  const isInReversePose = useRef(false)
  const isInDriftLeftPose = useRef(false)
  const isInDriftRightPose = useRef(false)

  const setFlamePositions = useGameStore((state: any) => state.setFlamePositions)

  const playAction = (name: ActionName, loopOnce = false) => {
    if (!actions || !actions[name]) return

    const nextAction = actions[name]

    if (currentAction.current !== nextAction) {
      if (currentAction.current) {
        currentAction.current.fadeOut(0.2)
      }

      nextAction.reset().setEffectiveWeight(1).fadeIn(0.2)

      if (loopOnce) {
        nextAction.setLoop(LoopOnce, 1)
        nextAction.clampWhenFinished = true
      } else {
        nextAction.setLoop(LoopRepeat, Infinity)
      }

      nextAction.play()
      currentAction.current = nextAction
    }
  }

  useEffect(() => {
    if (actions['IDLE-KART']) {
      currentAction.current = actions['IDLE-KART'].play()
    }
    if (actions['wind']) {
      windActionRef.current = actions['wind'].play()
    }
    if (sceneRef.current) {
      sceneRef.current.traverse((obj) => {
        if ((obj as THREE.Mesh).isMesh) {
          obj.castShadow = true
          obj.receiveShadow = true
        }
      })
    }
  }, [actions])

  useFrame((state, delta) => {
    const time = state.clock.getElapsedTime()

    if (windActionRef.current) {
      windActionRef.current.setEffectiveTimeScale(speed.current / 15)
    }

    // Check if reversing (negative speed)
    const isReversing = speed.current < -1

    // Drift directions: left = 1.4, right = -1.4, none = 0
    const isDriftingLeft = driftDirection.current > 1
    const isDriftingRight = driftDirection.current < -1

    if (isReversing) {
      // Reversing animations
      if (inputTurn.current > 0.01) {
        // Turning left while reversing
        playAction('reverse-left', true)
        isInReversePose.current = true
      } else if (inputTurn.current < -0.01) {
        // Turning right while reversing
        playAction('reverse-right-baked', true)
        isInReversePose.current = true
      } else {
        // Going straight backwards
        if (!isInReversePose.current) {
          // First time entering reverse - play the transition animation
          playAction('reverse', true)
          isInReversePose.current = true
        } else if (currentAction.current !== actions['reverse']) {
          // Returning from reverse-left/right - jump to final frame of reverse
          const reverseAction = actions['reverse']
          if (reverseAction) {
            if (currentAction.current) {
              currentAction.current.fadeOut(0.2)
            }
            reverseAction.reset()
            reverseAction.setLoop(LoopOnce, 1)
            reverseAction.clampWhenFinished = true
            reverseAction.time = reverseAction.getClip().duration // Jump to final frame
            reverseAction.setEffectiveWeight(1)
            reverseAction.fadeIn(0.2)
            reverseAction.play()
            currentAction.current = reverseAction
          }
        }
      }
    } else {
      // Not reversing anymore - reset the flag
      isInReversePose.current = false
      
      if (isDriftingLeft) {
        // Reset right drift flag when drifting left
        isInDriftRightPose.current = false
        
        // When drifting left, the neutral inputTurn is driftDirection * 0.1
        const neutralDriftInput = driftDirection.current * 0.1
        const inputDiff = inputTurn.current - neutralDriftInput

        if (inputDiff > 0.05) {
          // Pressing A - intensifying the drift
          playAction('drift-intense-left', true)
          isInDriftLeftPose.current = true
        } else {
          // Neutral drift position
          if (!isInDriftLeftPose.current) {
            // First time entering drift - play the transition animation
            playAction('drift-neutral-left', true)
            isInDriftLeftPose.current = true
          } else if (currentAction.current !== actions['drift-neutral-left']) {
            // Returning from intense - jump to final frame of neutral
            const neutralAction = actions['drift-neutral-left']
            if (neutralAction) {
              if (currentAction.current) {
                currentAction.current.fadeOut(0.2)
              }
              neutralAction.reset()
              neutralAction.setLoop(LoopOnce, 1)
              neutralAction.clampWhenFinished = true
              neutralAction.time = neutralAction.getClip().duration // Jump to final frame
              neutralAction.setEffectiveWeight(1)
              neutralAction.fadeIn(0.2)
              neutralAction.play()
              currentAction.current = neutralAction
            }
          }
        }
      } else if (isDriftingRight) {
        // Reset left drift flag when drifting right
        isInDriftLeftPose.current = false
        
        // When drifting right, the neutral inputTurn is driftDirection * 0.1 (negative)
        const neutralDriftInput = driftDirection.current * 0.1
        const inputDiff = inputTurn.current - neutralDriftInput

        if (inputDiff < -0.05) {
          // Pressing D - intensifying the drift
          playAction('drift-intense-right', true)
          isInDriftRightPose.current = true
        } else {
          // Neutral drift position
          if (!isInDriftRightPose.current) {
            // First time entering drift - play the transition animation
            playAction('drift-neutral-right', true)
            isInDriftRightPose.current = true
          } else if (currentAction.current !== actions['drift-neutral-right']) {
            // Returning from intense - jump to final frame of neutral
            const neutralAction = actions['drift-neutral-right']
            if (neutralAction) {
              if (currentAction.current) {
                currentAction.current.fadeOut(0.2)
              }
              neutralAction.reset()
              neutralAction.setLoop(LoopOnce, 1)
              neutralAction.clampWhenFinished = true
              neutralAction.time = neutralAction.getClip().duration // Jump to final frame
              neutralAction.setEffectiveWeight(1)
              neutralAction.fadeIn(0.2)
              neutralAction.play()
              currentAction.current = neutralAction
            }
          }
        }
      } else {
        // Not drifting - reset drift flags
        isInDriftLeftPose.current = false
        isInDriftRightPose.current = false
        
        if (inputTurn.current < -0.01) {
          playAction('TURN-RIGHT', true)
        } else if (inputTurn.current > 0.01) {
          playAction('TURN-LEFT', true)
        } else {
          playAction('IDLE-KART', false)
        }
      }
    }

    if (wheelPRY.current && sceneRef.current) {
      sceneRef.current.rotation.x = wheelPRY.current[0]
      sceneRef.current.rotation.z = wheelPRY.current[1]
      sceneRef.current.position.y = damp(sceneRef.current.position.y, wheelPRY.current[2], 24, delta)
    }

    if (group.current) {
      group.current.rotation.y = damp(
        group.current.rotation.y,
        driftDirection.current * 0.4,
        4,
        delta
      )
    }

    if (kartBodyRef.current) {
      kartBodyRef.current.rotation.x = -Math.PI + Math.sin(time * 80) * 0.003
    }

    if (speed.current < 10) {
      smoke1Ref.current?.startEmitting()
      smoke2Ref.current?.startEmitting()
    } else {
      smoke1Ref.current?.stopEmitting()
      smoke2Ref.current?.stopEmitting()
    }

    if (flamePositionLeftRef.current && flamePositionRightRef.current) {
      setFlamePositions([
        flamePositionLeftRef.current.position,
        flamePositionRightRef.current.position,
      ])
    }
  })
  return (
    <group ref={group} dispose={null} position={[0, 0, 0]} scale={2}>
      <group ref={wheelsRef}>
        <Wheels
          speed={speed}
          inputTurn={inputTurn}
          driftDirection={driftDirection}
          driftPower={driftPower}
          jumpOffset={jumpOffset}
          wheelPRY={wheelPRY}
          backWheelOffset={backWheelOffset}
        />
      </group>
      <group ref={sceneRef} name="Scene">
        <group name="rig">
          <primitive object={nodes.root} />
          <primitive object={nodes['MCH-torsoparent']} />
          <primitive object={nodes['MCH-hand_ikparentL']} />
          <primitive object={nodes['MCH-upper_arm_ik_targetparentL']} />
          <primitive object={nodes['MCH-hand_ikparentR']} />
          <primitive object={nodes['MCH-upper_arm_ik_targetparentR']} />
          <primitive object={nodes['MCH-foot_ikparentL']} />
          <primitive object={nodes['MCH-thigh_ik_targetparentL']} />
          <primitive object={nodes['MCH-foot_ikparentR']} />
          <primitive object={nodes['MCH-thigh_ik_targetparentR']} />
        </group>
        <mesh
          castShadow
          receiveShadow
          ref={kartBodyRef}
          name="body"
          geometry={nodes.body.geometry}
          material={materials.m_Body}
          rotation={[-Math.PI, 0, -Math.PI]}
          scale={0.522}
          position-y={0.01}
        >
          <Flames />
          <group position={[0.5, 0.55, -1.5]} rotation-x={Math.PI / 9} ref={flamePositionLeftRef}>
            <VFXEmitter ref={smoke1Ref} emitter="smoke" settings={SMOKE_VFX_SETTINGS as any} />
          </group>
          <group position={[-0.5, 0.55, -1.5]} rotation-x={Math.PI / 9} ref={flamePositionRightRef}>
            <VFXEmitter ref={smoke2Ref} emitter="smoke" settings={SMOKE_VFX_SETTINGS as any} />
          </group>
        </mesh>
        <skinnedMesh
          castShadow
          receiveShadow
          name="Cube004"
          geometry={nodes.Cube004.geometry}
          material={materials['Material.002']}
          skeleton={nodes.Cube004.skeleton}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          name="Cube005"
          geometry={nodes.Cube005.geometry}
          material={materials['Material.003']}
          skeleton={nodes.Cube005.skeleton}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          name="Cube006"
          geometry={nodes.Cube006.geometry}
          material={materials.Material}
          skeleton={nodes.Cube006.skeleton}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          name="Cylinder"
          geometry={nodes.Cylinder.geometry}
          material={materials['Material.007']}
          skeleton={nodes.Cylinder.skeleton}
        />
      </group>
    </group>
  )
}

useGLTF.preload('./models/witch-test-transformed.glb')
